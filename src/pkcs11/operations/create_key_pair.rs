use std::time::SystemTime;

use cryptoki::mechanism::Mechanism;
use cryptoki::object::Attribute;
use kmip::types::common::UniqueIdentifier;

use crate::config::Cfg;
use crate::pkcs11::error::Error;
use crate::pkcs11::util::init_pkcs11;

pub struct CreatedKeyPair {
    pub public_key_id: UniqueIdentifier,
    pub private_key_id: UniqueIdentifier,
}

pub fn create_key_pair(
    cfg: &Cfg,
    mut pub_attrs: Vec<Attribute>,
    mut priv_attrs: Vec<Attribute>,
    mechanism: Mechanism,
) -> Result<CreatedKeyPair, Error> {
    // TODO: Consider what strategy to use for ID generation.
    // - Is it an option and is it useful to NOT supply an ID and get an
    //   autogenerated ID from the HSM?
    //
    // - Do we need IDs to be in some way recognizably ours (so as to know in
    //   an HSM which keys were generated by Nameshed vs some other means)?
    //
    // - Should IDs even be specific to a given Nameshed deployment (so as to
    //   be able to distinguish keys generated say by development and
    //   pre-production deployments using the same HSM)?
    //
    // - Do we need separate public and private key IDs? OpenDNSSEC uses the
    //   same ID and same label for both the public and the private key.
    //   Regardless of whether we use the same ID or two separate IDs, the
    //   KMIP response has mandatory fields for separate IDs for the public
    //   and private key. In the OpenDNSSEC case when CKA_TOKEN is false for
    //   the public key the ID is useless anyway presumably as the key will be
    //   discarded at the end of the PKCS#11 session. OpenDNSSEC even calls
    //   C_DestroyObject on the public key to discard it immediately if
    //   CKA_TOKEN is false for the public key.
    //
    // - Should we do as OpenDNSSEC does which is to use the PKCS#11
    //   C_GenerateRandom() function to generate a random sequence of 16 bytes
    //   to use as the CKA_ID, then check using the PKCS#11 C_FindObjects()
    //   API if that key ID is already taken, and if so repeat the process?
    //   OpenDNSSEC then uses a 33 byte CKA_LABEL to store the hex
    //   representation of the generated ID.
    //
    // - Should we do as Krill does which is to use OpenSSL to generate a
    //   random sequence of 20 bytes as the CKA_ID, and "Krill" as the
    //   CKA_LABEL.
    //
    // - What do PowerDNS, Knot, etc do?

    // TODO: Consider which PKCS#11 attributes to use for the keys, and which
    // of these should be determined here vs which should be determined by the
    // details of the KMIP Create Key Pair request.
    //
    // - OpenDNSSEC uses:
    //    Public key:
    //      CKA_ID               Random HSM generated not-already-used 16 byte
    //                           sequence.
    //      CKA_LABEL            Hex representation of CKA_ID.
    //      CKA_KEY_TYPE         CKK_RSA
    //      CKA_VERIFY           True
    //      CKA_ENCRYPT          False
    //      CKA_WRAP             False
    //      CKA_TOKEN            Configurable.
    //      CKA_MODULUS_BITS     Set to the RSA key size to generate, e.g.
    //                           2048, based on the KMIP request.
    //      CKA_PUBLIC_EXPONENT  [1, 0, 1]
    //
    //    Private key:
    //      CKA_ID               Same as public key.
    //      CKA_LABEL            Same as public key.
    //      CKA_KEY_TYPE         Same as public key.
    //      CKA_SIGN             True
    //      CKA_DECRYPT          False
    //      CKA_UNWRAP           False
    //      CKA_SENSITIVE        True
    //      CKA_TOKEN            True
    //      CKA_PRIVATE          True
    //      CKA_EXTRACTABLE      Configurable.
    //
    //     Mechanism: CKM_RSA_PKCS_KEY_PAIR_GEN
    //
    // - Krill uses:
    //   Same as OpenDNSSEC with the following exceptions:
    //     CKA_ID                Random OpenSSL generated 20 byte sequence.
    //     CKA_LABEL             "Krill".
    //     CKA_TOKEN             Always set to true for public keys.
    //     CKA_MODULUS_BITS      Always set to 2048.
    //     CKA_SENSITIVE         Not set by default.
    //     CKA_PRIVATE           Configurable.
    //     CKA_SENSITIVE         Configurable.
    //     CKA_EXCTRACTABLE      Not set by default.
    //
    //     Krill also allows extra attributes to be defined in config,
    //     separately for public and private keys.
    //
    //     Krill maintains a persistent mapping of RFC 5280 Subject Key
    //     Identifiers to generated 20 byte random IDs.
    //
    // - What do PowerDNS, Knot, etc do?

    let epoch_time_now = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap()
        .as_secs();

    let base_name = format!("nameshed_{epoch_time_now}");
    let pub_id = format!("{base_name}_pub").as_bytes().to_vec();
    let priv_id = format!("{base_name}_priv").as_bytes().to_vec();

    let mut pub_key_template = vec![
        Attribute::Id(pub_id.clone()),
        Attribute::Verify(true),
        Attribute::Encrypt(false),
        Attribute::Wrap(false),
        Attribute::Token(true),
    ];
    pub_key_template.append(&mut pub_attrs);

    let mut priv_key_template = vec![
        Attribute::Id(priv_id.clone()),
        Attribute::Sign(true),
        Attribute::Decrypt(false),
        Attribute::Unwrap(false),
        Attribute::Token(true),
        Attribute::Private(true),
        Attribute::Sensitive(true),
    ];
    priv_key_template.append(&mut priv_attrs);

    eprintln!("Public key ID: {pub_id:?}");
    eprintln!("Private key ID: {priv_id:?}");

    // TODO: The error returned is a bit useless when Display'd, e.g.:
    //
    //   ERROR ThreadId(02) domain::crypto::kmip::sign: KMIP request failed:
    //   Server error: Operation CreateKeyPair failed: Failed to create key
    //   pair: Relay failed to invoke PKCS#11 function
    //   'Function::GenerateKeyPair': An invalid value was specified for a
    //   particular attribute in a template.  See Section 4.1 for more
    //   information.
    //
    // Firstly, that "Function::GenerateKeyPair" should say C_GenerateKeyPair.
    //
    // Secondly, section 4.1 of which document?
    //
    // This output comes from the cryptoki crate I think.
    //
    // In the particular case above the issue was that the requested RSA key
    // size of 1048 is apparently not permitted by the YubiHSM, with 2048 the
    // error goes away. That is completely not obvious from this error
    // message.
    let session = init_pkcs11(cfg)?;
    session.generate_key_pair(&mechanism, &pub_key_template, &priv_key_template)?;

    Ok(CreatedKeyPair {
        public_key_id: UniqueIdentifier(hex::encode_upper(pub_id)),
        private_key_id: UniqueIdentifier(hex::encode_upper(priv_id)),
    })
}
